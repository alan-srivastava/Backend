MOST COMMON HEADERS
Headers control communication, authentication, caching, CORS, and security between client & server.

1. Accept
ğŸ‘‰ Tells server what response format client wants
Meaning â†’ â€œSend me JSONâ€

2. User-Agent
ğŸ‘‰ Info about client/browser/app
Used for:
logging
analytics
blocking bots

3. Authorization
ğŸ‘‰ Sends auth credentials/token
Used for:
login verification
protected routes

4. Content-Type
ğŸ‘‰ Tells server what type of data is being sent
Content-Type: application/json
Other types:
multipart/form-data (file upload)
text/plain

5. Cookie
ğŸ‘‰ Stores session/user data

6. Cache-Control
ğŸ‘‰ Controls caching behavior
Cache-Control: no-cache
Used for:
prevent old data
improve performance

HTTP STATUS CODE
1**- Used to pass info to user
2**- sucess
3**-  Data has been removed or shifted
4**- client error cames from cilet mistakes
5**- server error


In app.js we defined a route for user registration using userRouter which is imported from user.routes.js. In user.routes.js, we defined a POST route "/register" that calls the registerUser function from user.controller.js when a request is made to that route. The registerUser function is wrapped with asyncHandler to handle
any asynchronous errors properly.


export {registerUser}; means we can allows multiple functions inside braces to use it into another file like import { registerUser, loginUser } from "./auth";
export default registerUser; means we can use only one function or variable at a time and import it into another file like import registerUser from import registerUser from "./auth";


Cloudinary Integration in Your Code:

Cloudinary is a cloud-based image/media storage service. Here's how it works in your app:

File Upload Flow:

User uploads files (avatar, coverImage) via multer
Files are temporarily stored locally on your server
Cloudinary SDK uploads them to the cloud
Key Files Involved:

cloudinary.js - Contains the upload logic
Uses cloudinary.uploader.upload() to send files to Cloudinary's servers
What Happens:

Files get stored on Cloudinary's CDN (Content Delivery Network)
You receive a public URL back (like http://res.cloudinary.com/dtktnla8e/image/upload/...)
This URL is saved in MongoDB instead of the actual file
Local temporary files are deleted after upload
Benefits:

No server storage needed - saves disk space
Fast delivery - CDN serves images globally
Easy image manipulation - Cloudinary can resize, crop, optimize
Scalable - handles unlimited uploads
In Your User Model:

avatar and coverImage fields store Cloudinary URLs
When user fetches their profile, they get the public image links
Images are always available via Cloudinary's servers


Diff between access token and refresh access token is that access token has short expiry time like 15 minutes to 1 hour and refresh token has long expiry time like 7 days to 30 days for example when user login to the application the server will generate both access token and refresh token and send it to the client the client will store the access token in memory and refresh token in http only cookie so when the access token expires the client can use the refresh token to get a new access token without asking user to login again this way user will have seamless experience while using the application.

MIDDLEWARE-- Middleware is a function that runs between the request and response to handle common tasks like authentication, logging, and validation, helping make code reusable and clean.

without middleware (Same auth code repeated)
app.get("/profile", (req, res) => {
  if (!req.headers.token) return res.send("Login first")
  res.send("Profile data")
})

app.get("/orders", (req, res) => {
  if (!req.headers.token) return res.send("Login first")
  res.send("Orders data")
})

With middleware
Step 1 â€” create middleware
const auth = (req, res, next) => {
  if (!req.headers.token)
    return res.send("Login first")

  next() // go to next step    Request â†’ auth middleware â†’ next() â†’ route â†’ Response

}


Step 2 â€” use it
app.get("/profile", auth, (req, res) => {
  res.send("Profile data")
})

app.get("/orders", auth, (req, res) => {
  res.send("Orders data")
})


Now:
auth runs first
then route runs

