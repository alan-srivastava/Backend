MOST COMMON HEADERS
Headers control communication, authentication, caching, CORS, and security between client & server.

1. Accept
ðŸ‘‰ Tells server what response format client wants
Meaning â†’ â€œSend me JSONâ€

2. User-Agent
ðŸ‘‰ Info about client/browser/app
Used for:
logging
analytics
blocking bots

3. Authorization
ðŸ‘‰ Sends auth credentials/token
Used for:
login verification
protected routes

4. Content-Type
ðŸ‘‰ Tells server what type of data is being sent
Content-Type: application/json
Other types:
multipart/form-data (file upload)
text/plain

5. Cookie
ðŸ‘‰ Stores session/user data

6. Cache-Control
ðŸ‘‰ Controls caching behavior
Cache-Control: no-cache
Used for:
prevent old data
improve performance

HTTP STATUS CODE
1**- Used to pass info to user
2**- sucess
3**-  Data has been removed or shifted
4**- client error cames from cilet mistakes
5**- server error


In app.js we defined a route for user registration using userRouter which is imported from user.routes.js. In user.routes.js, we defined a POST route "/register" that calls the registerUser function from user.controller.js when a request is made to that route. The registerUser function is wrapped with asyncHandler to handle
any asynchronous errors properly.


export {registerUser}; means we can allows multiple functions inside braces to use it into another file like import { registerUser, loginUser } from "./auth";
export default registerUser; means we can use only one function or variable at a time and import it into another file like import registerUser from import registerUser from "./auth";


Cloudinary Integration in Your Code:

Cloudinary is a cloud-based image/media storage service. Here's how it works in your app:

File Upload Flow:

User uploads files (avatar, coverImage) via multer
Files are temporarily stored locally on your server
Cloudinary SDK uploads them to the cloud
Key Files Involved:

cloudinary.js - Contains the upload logic
Uses cloudinary.uploader.upload() to send files to Cloudinary's servers
What Happens:

Files get stored on Cloudinary's CDN (Content Delivery Network)
You receive a public URL back (like http://res.cloudinary.com/dtktnla8e/image/upload/...)
This URL is saved in MongoDB instead of the actual file
Local temporary files are deleted after upload
Benefits:

No server storage needed - saves disk space
Fast delivery - CDN serves images globally
Easy image manipulation - Cloudinary can resize, crop, optimize
Scalable - handles unlimited uploads
In Your User Model:

avatar and coverImage fields store Cloudinary URLs
When user fetches their profile, they get the public image links
Images are always available via Cloudinary's servers


Diff between access token and refresh access token is that access token has short expiry time like 15 minutes to 1 hour and refresh token has long expiry time like 7 days to 30 days for example when user login to the application the server will generate both access token and refresh token and send it to the client the client will store the access token in memory and refresh token in http only cookie so when the access token expires the client can use the refresh token to get a new access token without asking user to login again this way user will have seamless experience while using the application.

MIDDLEWARE-- Middleware is a function that runs between the request and response to handle common tasks like authentication, logging, and validation, helping make code reusable and clean.

without middleware (Same auth code repeated)
app.get("/profile", (req, res) => {
  if (!req.headers.token) return res.send("Login first")
  res.send("Profile data")
})

app.get("/orders", (req, res) => {
  if (!req.headers.token) return res.send("Login first")
  res.send("Orders data")
})

With middleware
Step 1 â€” create middleware
const auth = (req, res, next) => {
  if (!req.headers.token)
    return res.send("Login first")

  next() // go to next step    Request â†’ auth middleware â†’ next() â†’ route â†’ Response

}


Step 2 â€” use it
app.get("/profile", auth, (req, res) => {
  res.send("Profile data")
})

app.get("/orders", auth, (req, res) => {
  res.send("Orders data")
})

Now:
auth runs first
then route runs

Difference between Access Token and refresh token:
Access tokens are short-lived tokens used to authenticate API requests, while refresh tokens are long-lived tokens used only to generate new access tokens when they expire. This improves security by limiting exposure while keeping the user logged in seamlessly.
Login
   â†“
Server gives:
   accessToken (15m)
   refreshToken (7d)

API calls â†’ use accessToken

If expired â†’
   send refreshToken â†’ get new accessToken


JWT--
JWT (JSON Web Token) is a stateless authentication mechanism that allows secure communication between client and server without storing session data on the server.
It contains 3 parts in its body:
Header: Which algorithm you are using.
Payload(DATA): What info do you have
Signature: checks the manipulation in payload info(It keeps the secret key for encryption(hide))

Register â†’ create account only

Login â†’
   create access + refresh
   store refresh in DB
   send tokens

Use app â†’
   access token for APIs

Access expired â†’                             Use refresh token silently
refresh â†’ new access                         â†’ get new access token
                                             â†’ continue automaticallyrefresh â†’ new access

Login again later â†’
   create NEW tokens
   replace refresh in DB
   old token invalid



